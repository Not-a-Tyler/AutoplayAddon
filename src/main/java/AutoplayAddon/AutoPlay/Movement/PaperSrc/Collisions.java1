package AutoplayAddon.AutoPlay.Movement.PaperSrc;

import net.minecraft.util.math.Vec3d;

import java.util.List;
import com.google.common.collect.ImmutableList;
import meteordevelopment.meteorclient.utils.player.ChatUtils;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShape;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.World;
import net.minecraft.world.border.WorldBorder;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;
import static meteordevelopment.meteorclient.MeteorClient.mc;

import static meteordevelopment.meteorclient.MeteorClient.mc;

public class Collisions {


    private Vec3d collide(Vec3d movement) {
        // Paper start - optimise collisions
        // This is a copy of vanilla's except that it uses strictly AABB math
        if (movement.x == 0.0 && movement.y == 0.0 && movement.z == 0.0) {
            return movement;
        }

        final World world = mc.player.getWorld();
        final Box currBoundingBox = mc.player.getBoundingBox();

        if (io.papermc.paper.util.CollisionUtil.isEmpty(currBoundingBox)) {
            return movement;
        }

        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
        try {
            final double stepHeight = (double)this.maxUpStep();
            final Box collisionBox;

            if (movement.x == 0.0 && movement.z == 0.0 && movement.y != 0.0) {
                if (movement.y > 0.0) {
                    collisionBox = io.papermc.paper.util.CollisionUtil.cutUpwards(currBoundingBox, movement.y);
                } else {
                    collisionBox = io.papermc.paper.util.CollisionUtil.cutDownwards(currBoundingBox, movement.y);
                }
            } else {
                if (stepHeight > 0.0 && (mc.player.isOnGround() || (movement.y < 0.0)) && (movement.x != 0.0 || movement.z != 0.0)) {
                    // don't bother getting the collisions if we don't need them.
                    if (movement.y <= 0.0) {
                        collisionBox = io.papermc.paper.util.CollisionUtil.expandUpwards(currBoundingBox.expandTowards(movement.x, movement.y, movement.z), stepHeight);
                    } else {
                        collisionBox = currBoundingBox.expandTowards(movement.x, Math.max(stepHeight, movement.y), movement.z);
                    }
                } else {
                    collisionBox = currBoundingBox.expandTowards(movement.x, movement.y, movement.z);
                }
            }

            io.papermc.paper.util.CollisionUtil.getCollisions(world, this, collisionBox, potentialCollisions, false, this.level.paperConfig().chunks.preventMovingIntoUnloadedChunks,
                false, false, null, null);

            if (collidingWithWorldBorder = io.papermc.paper.util.CollisionUtil.isCollidingWithBorderEdge(world.getWorldBorder(), collisionBox)) { // Paper - this line *is* correct, ignore the IDE warning about assignments being used as a condition
                io.papermc.paper.util.CollisionUtil.addBoxesToIfIntersects(world.getWorldBorder().getCollisionShape(), collisionBox, potentialCollisions);
            }

            final Vec3d limitedMoveVector = io.papermc.paper.util.CollisionUtil.performCollisions(movement, currBoundingBox, potentialCollisions);

            if (stepHeight > 0.0
                && (this.onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
                && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
                Vec3d vec3d2 = io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3d(movement.x, stepHeight, movement.z), currBoundingBox, potentialCollisions);
                final Vec3d vec3d3 = io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3d(0.0, stepHeight, 0.0), currBoundingBox.expandTowards(movement.x, 0.0, movement.z), potentialCollisions);

                if (vec3d3.y < stepHeight) {
                    final Vec3d vec3d4 = io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3d(movement.x, 0.0D, movement.z), currBoundingBox.move(vec3d3), potentialCollisions).add(vec3d3);

                    if (vec3d4.horizontalDistanceSqr() > vec3d2.horizontalDistanceSqr()) {
                        vec3d2 = vec3d4;
                    }
                }

                if (vec3d2.horizontalDistanceSqr() > limitedMoveVector.horizontalDistanceSqr()) {
                    return vec3d2.add(io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3d(0.0D, -vec3d2.y + movement.y, 0.0D), currBoundingBox.move(vec3d2), potentialCollisions));
                }

                return limitedMoveVector;
            } else {
                return limitedMoveVector;
            }
        } finally {
            io.papermc.paper.util.CachedLists.returnTempCollisionList(potentialCollisions);
        }
        // Paper end - optimise collisions
    }

}
